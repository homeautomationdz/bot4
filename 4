import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.signal import argrelextrema
from telegram import Bot
from telegram.error import TelegramError
import asyncio
import io  # Import io for in-memory file handling
from binance.client import Client  # Import Binance Client
import config4  # Import the configuration file

def fetch_binance_data(symbol, timeframe='1h', limit=100):
    try:
        client = Client(config4.api_key, config4.api_secret)  # Use the API key and secret from config4.py
        ohlcv = client.get_historical_klines(symbol, timeframe, limit=limit)
        data = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume',
                                              'close_time', 'quote_asset_volume', 'number_of_trades',
                                              'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'])
        data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
        return data[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
    except Exception as e:
        print(f"Error fetching data: {e}")
        return pd.DataFrame()

def calculate_slopes(data, length, mult, calcMethod):
    if calcMethod == 'Atr':
        slope = data['close'].rolling(window=length).apply(lambda x: np.mean(np.abs(np.diff(x)))) / length * mult
    elif calcMethod == 'Stdev':
        slope = data['close'].rolling(window=length).std() / length * mult
    elif calcMethod == 'Linreg':
        n = np.arange(length)
        slope = data['close'].rolling(window=length).apply(lambda x: np.polyfit(n, x, 1)[0]) * mult
    else:
        raise ValueError("Invalid calculation method")
    
    return slope

def calculate_trendlines(data, length, mult, calcMethod):
    slope = calculate_slopes(data, length, mult, calcMethod)
    
    # Ensure 'high' and 'low' columns are numeric
    data['high'] = pd.to_numeric(data['high'], errors='coerce')
    data['low'] = pd.to_numeric(data['low'], errors='coerce')

    # Find peaks and troughs
    window_size = length
    peaks = data.iloc[argrelextrema(data['high'].values, np.greater_equal, order=window_size)[0]]
    troughs = data.iloc[argrelextrema(data['low'].values, np.less_equal, order=window_size)[0]]

    if len(peaks) < 2 or len(troughs) < 2:
        return None, None

    # Initialize trendlines
    trendline_peaks = np.full(len(data), np.nan)
    trendline_troughs = np.full(len(data), np.nan)

    for i in range(len(data)):
        if len(peaks) > 1:
            peak_value = peaks['high'].iloc[-1] if not pd.isna(peaks['high'].iloc[-1]) else 0
            slope_value = slope.iloc[i] if not pd.isna(slope.iloc[i]) else 0
            trendline_peaks[i] = peak_value - slope_value
        
        if len(troughs) > 1:
            trough_value = troughs['low'].iloc[-1] if not pd.isna(troughs['low'].iloc[-1]) else 0
            trendline_troughs[i] = trough_value + slope_value

    return trendline_peaks, trendline_troughs

def detect_breakouts(data, trendline_peaks, trendline_troughs):
    # Ensure 'close' is numeric
    data['close'] = pd.to_numeric(data['close'], errors='coerce')

    breakout_up = data[data['close'] > trendline_peaks]
    breakout_down = data[data['close'] < trendline_troughs]
    return breakout_up, breakout_down

def plot_trendlines(data, trendline_peaks, trendline_troughs, breakout_up, breakout_down, symbol, timeframe):
    plt.figure(figsize=(12, 6))
    plt.plot(data['timestamp'], data['close'], label='Close Price')
    
    # Plot support and resistance lines
    plt.plot(data['timestamp'], trendline_peaks, label='Resistance Trendline', linestyle='--', color='red')
    plt.plot(data['timestamp'], trendline_troughs, label='Support Trendline', linestyle='--', color='green')
    
    # Plot breakout points
    plt.scatter(breakout_up['timestamp'], breakout_up['close'], color='blue', label='Breakout Up Points')
    plt.scatter(breakout_down['timestamp'], breakout_down['close'], color='orange', label='Breakout Down Points')

    # Extend the trendlines
    last_idx = len(data) - 1
    future_dates = pd.date_range(start=data['timestamp'].iloc[-1], periods=50, freq='H')
    plt.plot(future_dates, trendline_peaks[-1] + np.arange(1, 51) * (trendline_peaks[-1] - trendline_peaks[-2]), linestyle='--', color='red')
    plt.plot(future_dates, trendline_troughs[-1] + np.arange(1, 51) * (trendline_troughs[-1] - trendline_troughs[-2]), linestyle='--', color='green')

    plt.xlabel('Timestamp')
    plt.ylabel('Price')
    plt.legend()
    plt.title(f'Trendline Breakout Detection for {symbol} ({timeframe})')  # Updated title

    # Save the plot to a BytesIO object
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)  # Move to the beginning of the BytesIO buffer
    plt.close()
    return buf  # Return the buffer

async def send_image_to_telegram(image_buffer):
    bot = Bot(token=config4.bot_token)  # Use the bot token from config4.py
    try:
        await bot.send_photo(chat_id=config4.chat_id, photo=image_buffer)  # Send the image buffer directly
    except TelegramError as e:
        print(f"Error sending image to Telegram: {e}")

def main():
    for symbol in config4.SELECTED_SYMBOLS:
        print(f"Fetching data for symbol: {symbol}")  # Debugging line
        timeframe = '1h'
        length = 14
        mult = 1.0
        calcMethod = 'Atr'
        
        data = fetch_binance_data(symbol, timeframe)
        if data.empty:
            print(f"No data fetched for {symbol}.")
            continue

        trendline_peaks, trendline_troughs = calculate_trendlines(data, length, mult, calcMethod)
        if trendline_peaks is None or trendline_troughs is None:
            print(f"Not enough data to calculate trendlines for {symbol}.")
            continue

        breakout_up, breakout_down = detect_breakouts(data, trendline_peaks, trendline_troughs)
        image_buffer = plot_trendlines(data, trendline_peaks, trendline_troughs, breakout_up, breakout_down, symbol, timeframe)
        
        # Run the async function using asyncio
        asyncio.run(send_image_to_telegram(image_buffer))

if __name__ == "__main__":
    main()
